<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spyrit.learning.model_Had_DCAN &mdash; spyrit 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> spyrit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">spyrit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>spyrit.learning.model_Had_DCAN</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spyrit.learning.model_Had_DCAN</h1><div class="highlight"><pre>
<span></span><span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1">#   This software is distributed under the terms</span>
<span class="c1">#   of the GNU Lesser General  Public Licence (LGPL)</span>
<span class="c1">#   See LICENSE.md for further details</span>
<span class="c1"># -----------------------------------------------------------------------------</span>

<span class="c1">#from __future__ import print_function, division</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..misc.pattern_choice</span> <span class="kn">import</span> <span class="n">Hadamard</span><span class="p">,</span> <span class="n">matrix2conv</span><span class="p">,</span> <span class="n">split</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>

<span class="kn">from</span> <span class="nn">..misc.disp</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1">#from ..misc.statistics import *</span>
<span class="c1">#import spyrit.misc.walsh_hadamard as wh</span>
<span class="c1">#from spyrit.misc.statistics import *</span>
<span class="kn">from</span> <span class="nn">spyrit.misc.statistics</span> <span class="kn">import</span> <span class="n">Cov2Var</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1">#######################################################################</span>
<span class="c1"># 1. Determine the important Hadamard Coefficients</span>
<span class="c1"># ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="c1"># Helps determining the statistical best </span>
<span class="c1"># Hadamard patterns for a given image size</span>
<span class="c1"># </span>

<div class="viewcode-block" id="hadamard_opt_spc"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.hadamard_opt_spc">[docs]</a><span class="k">def</span> <span class="nf">hadamard_opt_spc</span><span class="p">(</span><span class="n">M</span> <span class="p">,</span><span class="n">root</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
    <span class="n">had_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">root</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">x</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.npy&#39;</span><span class="p">);</span>
    <span class="n">had_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="n">had_mat</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">),(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">));</span>
    <span class="n">msk</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">had_comp</span><span class="p">)</span><span class="o">&gt;</span><span class="n">M</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    
    <span class="n">conv</span> <span class="o">=</span> <span class="n">Hadamard</span><span class="p">(</span><span class="n">msk</span><span class="p">);</span> 

    <span class="k">return</span> <span class="n">conv</span></div>


<div class="viewcode-block" id="img2mask"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.img2mask">[docs]</a><span class="k">def</span> <span class="nf">img2mask</span><span class="p">(</span><span class="n">Value_map</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">Value_map</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">));</span>
    <span class="n">ranked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="n">Value_map</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">),(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">));</span>
    <span class="n">msk</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">ranked_data</span><span class="p">)</span><span class="o">&gt;</span><span class="n">M</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">msk</span></div>


<div class="viewcode-block" id="Permutation_Matrix_root"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Permutation_Matrix_root">[docs]</a><span class="k">def</span> <span class="nf">Permutation_Matrix_root</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Permutaion Matrix For The Hadamard Coefficients that ranks</span>
<span class="sd">        The Coefficients according to the Matrix defined By root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">had_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">had_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">Reorder</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="n">had_mat</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">);</span>
    <span class="n">Columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">));</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">));</span>
    <span class="n">P</span><span class="p">[</span><span class="n">Reorder</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Columns</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="Permutation_Matrix"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Permutation_Matrix">[docs]</a><span class="k">def</span> <span class="nf">Permutation_Matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns permutation matrix from sampling map</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        mat (np.ndarray): A a n-by-n sampling map, where high value means high significance.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        P (np.ndarray): A n*n-by-n*n permutation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">Reorder</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="n">mat</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">);</span>
    <span class="n">Columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">));</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">));</span>
    <span class="n">P</span><span class="p">[</span><span class="n">Reorder</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Columns</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="subsample"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.subsample">[docs]</a><span class="k">def</span> <span class="nf">subsample</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subsample forward operator from sampling map</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        H (np.ndarray): Full forward operator, a m-by-n array</span>
<span class="sd">        mat (np.ndarray): Sampling map</span>
<span class="sd">        M (int): number of measurements to keep, with M &lt;= m</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Hsub (np.ndarray): Subsampled forward operator, a M-by-n array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">Hsub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span><span class="n">H</span><span class="p">);</span>
    <span class="n">Hsub</span> <span class="o">=</span> <span class="n">Hsub</span><span class="p">[:</span><span class="n">M</span><span class="p">,:];</span>
    <span class="k">return</span> <span class="n">Hsub</span></div>


<div class="viewcode-block" id="maximum_Variance_Pattern"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.maximum_Variance_Pattern">[docs]</a><span class="k">def</span> <span class="nf">maximum_Variance_Pattern</span><span class="p">(</span><span class="n">Cov</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the patterns corresponding to coefficient that have the maximun</span>
<span class="sd">        variance for a given image database</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Var</span> <span class="o">=</span> <span class="n">Cov2Var</span><span class="p">(</span><span class="n">Cov</span><span class="p">)</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span>
    <span class="n">Pmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span><span class="n">H</span><span class="p">);</span>
    <span class="n">Pmat</span> <span class="o">=</span> <span class="n">Pmat</span><span class="p">[:</span><span class="n">M</span><span class="p">,:];</span>
    <span class="k">return</span> <span class="n">Pmat</span><span class="p">,</span> <span class="n">Perm</span></div>

<div class="viewcode-block" id="permutation_from_ind"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.permutation_from_ind">[docs]</a><span class="k">def</span> <span class="nf">permutation_from_ind</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">Columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
    <span class="n">P</span><span class="p">[</span><span class="n">ind</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Columns</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="ranking_matrix"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.ranking_matrix">[docs]</a><span class="k">def</span> <span class="nf">ranking_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the coefficient of a matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="n">mat</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="Variance_ranking"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Variance_ranking">[docs]</a><span class="k">def</span> <span class="nf">Variance_ranking</span><span class="p">(</span><span class="n">Cov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns rank of the variance given the covariance</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        Cov (np.ndarray): Covariance matrix.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Ind (np.ndarray): Ranking between 1 and length of Cov</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Var</span> <span class="o">=</span> <span class="n">Cov2Var</span><span class="p">(</span><span class="n">Cov</span><span class="p">)</span>
    <span class="n">Ind</span> <span class="o">=</span> <span class="n">ranking_matrix</span><span class="p">(</span><span class="n">Var</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Ind</span></div>

<div class="viewcode-block" id="Variance_mask"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Variance_mask">[docs]</a><span class="k">def</span> <span class="nf">Variance_mask</span><span class="p">(</span><span class="n">Cov</span><span class="p">,</span><span class="n">eta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a mask indicating the coefficients with maximum variance</span>

<span class="sd">    Args:</span>
<span class="sd">        Cov (np.ndarray): Covariance matrix.</span>
<span class="sd">        eta (float): Sampling ratio between 0 and 1</span>

<span class="sd">    Returns:</span>
<span class="sd">        mask (boolean array): 1 to keep, 0 otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">Variance_ranking</span><span class="p">(</span><span class="n">Cov</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">ind</span><span class="o">&lt;</span><span class="n">M</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">mask</span></div>

    
<div class="viewcode-block" id="meas2img"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.meas2img">[docs]</a><span class="k">def</span> <span class="nf">meas2img</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="n">Ord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return image from measurement vector</span>

<span class="sd">    Args:</span>
<span class="sd">        meas (ndarray): Measurement vector.</span>
<span class="sd">        Ord (ndarray): Order matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        Img (ndarray): Measurement image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ord</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)))</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Ord</span><span class="p">)</span>
    <span class="n">Img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Perm</span><span class="p">),</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ord</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Img</span></div>

<div class="viewcode-block" id="img2meas"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.img2meas">[docs]</a><span class="k">def</span> <span class="nf">img2meas</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Ord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return measurement vector from image (not TESTED)</span>

<span class="sd">    Args:</span>
<span class="sd">        im (np.ndarray): Image.</span>
<span class="sd">        Ord (np.ndarray): Order matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        meas (np.ndarray): Measurement vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Ord</span><span class="p">)</span>
    <span class="n">meas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">meas</span></div>

<div class="viewcode-block" id="meas2img_torch"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.meas2img_torch">[docs]</a><span class="k">def</span> <span class="nf">meas2img_torch</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="n">Ord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return image from measurement vector (NOT TESTED, requires too much memory?)</span>

<span class="sd">    Args:</span>
<span class="sd">        meas (torch.Tensor): Measurement vector.</span>
<span class="sd">        Ord (np.ndarray): Order matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        Img (torch.Tensor): Measurement image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ord</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="n">meas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Ord</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">Perm</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">meas</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">Perm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span><span class="n">meas</span><span class="p">)</span> <span class="c1"># Requires too much memory</span>
    
    <span class="k">return</span> <span class="n">Img</span></div>

<div class="viewcode-block" id="Hadamard_stat_completion_matrices"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Hadamard_stat_completion_matrices">[docs]</a><span class="k">def</span> <span class="nf">Hadamard_stat_completion_matrices</span><span class="p">(</span><span class="n">Cov_had</span><span class="p">,</span> <span class="n">Mean_had</span><span class="p">,</span> <span class="n">CR</span><span class="p">):</span>
    <span class="n">img_size</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">Mean_had</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    
    <span class="c1"># choice of patterns</span>
    <span class="n">Var</span> <span class="o">=</span> <span class="n">Cov2Var</span><span class="p">(</span><span class="n">Cov_had</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">wh</span><span class="o">.</span><span class="n">walsh2_matrix</span><span class="p">(</span><span class="n">img_size</span><span class="p">)</span><span class="o">/</span><span class="n">img_size</span>

    <span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Cov_had</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">)))</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Mean_had</span><span class="p">,</span> <span class="p">(</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[:</span><span class="n">CR</span><span class="p">];</span>

    <span class="n">Sigma1</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[:</span><span class="n">CR</span><span class="p">,:</span><span class="n">CR</span><span class="p">]</span>
    <span class="n">Sigma21</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">CR</span><span class="p">:,:</span><span class="n">CR</span><span class="p">]</span>
    
    <span class="n">W_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">CR</span><span class="p">))</span>
    <span class="n">W_p</span><span class="p">[:</span><span class="n">CR</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">CR</span><span class="p">);</span>
    <span class="n">W_p</span><span class="p">[</span><span class="n">CR</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sigma21</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Sigma1</span><span class="p">));</span>
    
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">W_p</span><span class="p">));</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">mu</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu1</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">H</span></div>

<div class="viewcode-block" id="stat_completion_matrices"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.stat_completion_matrices">[docs]</a><span class="k">def</span> <span class="nf">stat_completion_matrices</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">Cov_had</span><span class="p">,</span> <span class="n">Mean_had</span><span class="p">,</span> <span class="n">CR</span><span class="p">):</span>
    
    <span class="n">img_size</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">Mean_had</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>

    <span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Cov_had</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">)))</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Mean_had</span><span class="p">,</span> <span class="p">(</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[:</span><span class="n">CR</span><span class="p">];</span>

    <span class="n">Sigma1</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[:</span><span class="n">CR</span><span class="p">,:</span><span class="n">CR</span><span class="p">]</span>
    <span class="n">Sigma21</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">CR</span><span class="p">:,:</span><span class="n">CR</span><span class="p">]</span>
    
    <span class="n">W_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">CR</span><span class="p">))</span>
    <span class="n">W_p</span><span class="p">[:</span><span class="n">CR</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">CR</span><span class="p">);</span>
    <span class="n">W_p</span><span class="p">[</span><span class="n">CR</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sigma21</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Sigma1</span><span class="p">));</span>
    
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">W_p</span><span class="p">));</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">mu</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu1</span></div>

<div class="viewcode-block" id="Hadamard_stat_completion_extract"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Hadamard_stat_completion_extract">[docs]</a><span class="k">def</span> <span class="nf">Hadamard_stat_completion_extract</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">CR</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="n">img_size</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">CR</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="Hadamard_stat_completion"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Hadamard_stat_completion">[docs]</a><span class="k">def</span> <span class="nf">Hadamard_stat_completion</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="n">nxny</span> <span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">img_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nxny</span><span class="p">)));</span>
    <span class="n">f_star</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,(</span><span class="n">m</span><span class="o">-</span><span class="n">mu1</span><span class="p">))</span>
    <span class="n">img_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">f_star</span><span class="p">,(</span><span class="n">img_size</span><span class="p">,</span><span class="n">img_size</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">img_rec</span><span class="p">;</span></div>

<div class="viewcode-block" id="Hadamard_stat_completion_comp"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Hadamard_stat_completion_comp">[docs]</a><span class="k">def</span> <span class="nf">Hadamard_stat_completion_comp</span><span class="p">(</span><span class="n">Cov</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Im</span><span class="p">,</span> <span class="n">CR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reconstruct (not TESTED)</span>

<span class="sd">    Args:</span>
<span class="sd">        Cov (np.ndarray): Covariance matrix.</span>
<span class="sd">        Mean (np.ndarray): Mean matrix.</span>
<span class="sd">        Im (np.ndarray): Data matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        meas (np.ndarray): Measurement vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img_size</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">Im</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">Var</span> <span class="o">=</span> <span class="n">Cov2Var</span><span class="p">(</span><span class="n">Cov</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">wh</span><span class="o">.</span><span class="n">walsh2_matrix</span><span class="p">(</span><span class="n">img_size</span><span class="p">)</span><span class="o">/</span><span class="n">img_size</span>

    <span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Cov</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">)))</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Mean</span><span class="p">,</span> <span class="p">(</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[:</span><span class="n">CR</span><span class="p">];</span>

    <span class="n">Sigma1</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[:</span><span class="n">CR</span><span class="p">,:</span><span class="n">CR</span><span class="p">]</span>
    <span class="n">Sigma21</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">CR</span><span class="p">:,:</span><span class="n">CR</span><span class="p">]</span>
    
    <span class="n">W_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">CR</span><span class="p">))</span>
    <span class="n">W_p</span><span class="p">[:</span><span class="n">CR</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">CR</span><span class="p">);</span>
    <span class="n">W_p</span><span class="p">[</span><span class="n">CR</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sigma21</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Sigma1</span><span class="p">));</span>
    
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">W_p</span><span class="p">));</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">mu</span><span class="p">));</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Im</span><span class="p">,</span> <span class="p">(</span><span class="n">img_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">CR</span><span class="p">];</span>
    <span class="n">f_star</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,(</span><span class="n">m</span><span class="o">-</span><span class="n">mu1</span><span class="p">))</span>
    <span class="n">img_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">f_star</span><span class="p">,(</span><span class="n">img_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">img_rec</span><span class="p">;</span></div>

<span class="c1">###############################################################################</span>
<span class="c1"># 2. NEW Convolutional Neural Network</span>
<span class="c1">###############################################################################</span>
<span class="c1">#==============================================================================</span>
<span class="c1"># A. NO NOISE</span>
<span class="c1">#==============================================================================    </span>
<div class="viewcode-block" id="compNet"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet">[docs]</a><span class="k">class</span> <span class="nc">compNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ord</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">compNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">even_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Cov</span> <span class="o">=</span> <span class="n">Cov</span>

        <span class="c1">#-- Hadamard patterns (full basis)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">wh</span><span class="o">.</span><span class="n">walsh2_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">H</span><span class="p">;</span> <span class="c1">#fht hadamard transform needs to be normalized</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>
        
        <span class="c1">#-- Hadamard patterns (undersampled basis)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Ord</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>         
            <span class="n">Ord</span> <span class="o">=</span> <span class="n">Cov2Var</span><span class="p">(</span><span class="n">Cov</span><span class="p">)</span>
            
        <span class="n">Perm</span> <span class="o">=</span> <span class="n">Permutation_Matrix</span><span class="p">(</span><span class="n">Ord</span><span class="p">)</span>
        <span class="n">Pmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span><span class="n">H</span><span class="p">);</span>
        <span class="n">Pmat</span> <span class="o">=</span> <span class="n">Pmat</span><span class="p">[:</span><span class="n">M</span><span class="p">,:];</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pmat</span> <span class="o">=</span> <span class="n">Pmat</span>
        <span class="n">Pconv</span> <span class="o">=</span> <span class="n">matrix2conv</span><span class="p">(</span><span class="n">Pmat</span><span class="p">);</span>

        <span class="c1">#-- Denoising parameters </span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Cov</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Perm</span><span class="p">)));</span>
        <span class="n">diag_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">diag_index</span><span class="p">];</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">Sigma</span><span class="p">[:</span><span class="n">M</span><span class="p">];</span>   <span class="c1"># Multiplication by n**2 as H &lt;- nH  leads to Cov &lt;- n**2 Cov </span>
                                    <span class="c1"># Division by 4 to get the covariance of images in [0 1], not [-1 1]</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Mean</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="n">P1</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">mean</span><span class="p">)</span>
        <span class="c1">#mu = np.dot(Perm, np.reshape(Mean, (n**2,1)))</span>
        <span class="n">mu1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">mu</span><span class="p">[:</span><span class="n">M</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_1</span> <span class="o">=</span> <span class="n">mu1</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_1</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#-- Measurement preprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Patt</span> <span class="o">=</span> <span class="n">Pconv</span><span class="p">;</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">Pconv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Patt</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Patt</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">;</span>

        <span class="c1">#-- Pseudo-inverse to determine levels of noise.</span>
        <span class="n">Pinv</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Pmat</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">Pinv</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">float</span><span class="p">();</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">;</span>
        <span class="c1"># definir la bonne pseudo inv</span>


        <span class="c1">#-- Measurement to image domain</span>
        <span class="k">if</span> <span class="n">variant</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#--- Statistical Matrix completion (no mean)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measurement to image domain: statistical completion (no mean)&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            
            <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu1</span> <span class="o">=</span> <span class="n">stat_completion_matrices</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">W</span><span class="p">;</span> 

            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">float</span><span class="p">();</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="n">variant</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#--- Statistical Matrix completion  </span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measurement to image domain: statistical completion&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu1</span> <span class="o">=</span> <span class="n">stat_completion_matrices</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">W</span><span class="p">;</span> 
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">mu1</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">float</span><span class="p">();</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">float</span><span class="p">();</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">;</span>
        
        <span class="k">elif</span> <span class="n">variant</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1">#--- Pseudo-inverse</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measurement to image domain: pseudo inverse&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span><span class="p">;</span>
       
        <span class="k">elif</span> <span class="n">variant</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="c1">#--- FC is learnt</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measurement to image domain: free&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
        <span class="c1">#-- Image correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recon</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([</span>
          <span class="p">(</span><span class="s1">&#39;conv1&#39;</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">4</span><span class="p">)),</span>
          <span class="p">(</span><span class="s1">&#39;relu1&#39;</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()),</span>
          <span class="p">(</span><span class="s1">&#39;conv2&#39;</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
          <span class="p">(</span><span class="s1">&#39;relu2&#39;</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()),</span>
          <span class="p">(</span><span class="s1">&#39;conv3&#39;</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="p">]));</span>

<div class="viewcode-block" id="compNet.forward"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_acquire</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_reconstruct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="c1"># Forward functions (with grad)</span>
    <span class="c1">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="compNet.forward_acquire"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_acquire">[docs]</a>    <span class="k">def</span> <span class="nf">forward_acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="c1">#--Scale input image</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> 
        <span class="c1">#--Acquisition</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">## x[:,:,1] = -1/N0 ????</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No noise&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">);</span> 
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.forward_reconstruct"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_reconstruct">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CompNet&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.forward_reconstruct_pinv"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_reconstruct_pinv">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span> </div>
    
<div class="viewcode-block" id="compNet.forward_reconstruct_mmse"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_reconstruct_mmse">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_mmse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.forward_preprocess"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">forward_preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="c1">#- Pre-processing (use batch norm to avoid division by N0 ?)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">even_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span><span class="p">];</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Patt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)),(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.forward_maptoimage"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_maptoimage">[docs]</a>    <span class="k">def</span> <span class="nf">forward_maptoimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="c1">#--Projection to the image domain</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
        
    
<div class="viewcode-block" id="compNet.forward_postprocess"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.forward_postprocess">[docs]</a>    <span class="k">def</span> <span class="nf">forward_postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recon</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.pinv"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.pinv">[docs]</a>    <span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pinv</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="c1"># Evaluation functions (no grad)</span>
    <span class="c1">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="compNet.acquire"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.acquire">[docs]</a>    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_acquire</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.evaluate_fcl"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.evaluate_fcl">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_fcl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
           <span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
           <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_acquire</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
           <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_reconstruct_mmse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
     
<div class="viewcode-block" id="compNet.evaluate_Pinv"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.evaluate_Pinv">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_Pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
           <span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
           <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_Pinv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.evaluate"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
           <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="compNet.reconstruct"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.compNet.reconstruct">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_reconstruct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>
   
<span class="c1">#==============================================================================    </span>
<span class="c1"># B. NOISY MEASUREMENTS (NOISE LEVEL IS VARYING)</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="noiCompNet"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet">[docs]</a><span class="k">class</span> <span class="nc">noiCompNet</span><span class="p">(</span><span class="n">compNet</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">N0</span><span class="o">=</span><span class="mi">2500</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ord</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">variant</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">Ord</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N0</span> <span class="o">=</span> <span class="n">N0</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">);</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Varying N0 = </span><span class="si">{:g}</span><span class="s2"> +/- </span><span class="si">{:g}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N0</span><span class="p">,</span><span class="n">sig</span><span class="o">*</span><span class="n">N0</span><span class="p">))</span>
        
<div class="viewcode-block" id="noiCompNet.forward_acquire"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet.forward_acquire">[docs]</a>    <span class="k">def</span> <span class="nf">forward_acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="c1">#--Scale input image      </span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">*</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;alpha in [</span><span class="si">{:.2f}</span><span class="s1">--</span><span class="si">{:.2f}</span><span class="s1">] photons&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        
        <span class="c1">#--Acquisition</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>     <span class="c1"># x[:,:,1] = -1/N0 ????</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">);</span> <span class="c1"># x[:,:,1] &lt; 0??? </span>
        
        <span class="c1">#--Measurement noise (Gaussian approximation of Poisson)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="noiCompNet.forward_preprocess"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet.forward_preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">forward_preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="c1">#-- Pre-processing(Recombining positive and negatve values+normalisation) </span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">even_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span><span class="p">];</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N0</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Patt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)),(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">));</span> 

        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="noiCompNet.forward_reconstruct_expe"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet.forward_reconstruct_expe">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_expe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess_expe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="noiCompNet.forward_reconstruct_pinv_expe"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet.forward_reconstruct_pinv_expe">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_pinv_expe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess_expe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>      

        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="noiCompNet.forward_reconstruct_comp_expe"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet.forward_reconstruct_comp_expe">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_comp_expe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess_expe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>   
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="noiCompNet.forward_preprocess_expe"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.noiCompNet.forward_preprocess_expe">[docs]</a>    <span class="k">def</span> <span class="nf">forward_preprocess_expe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        
        <span class="c1">#-- Recombining positive and negative values</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">even_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span><span class="p">];</span>
        
        <span class="c1">#-- Estimating and normalizing by N0 = K*alpha</span>
        <span class="n">x_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="n">N0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_est</span><span class="p">)</span>
        <span class="n">N0</span> <span class="o">=</span> <span class="n">N0</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1">#--</span>
        <span class="n">N0_est</span> <span class="o">=</span> <span class="n">N0</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N0_est</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Patt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)),(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">N0</span></div></div>


<span class="c1">#==============================================================================    </span>
<span class="c1"># B. NOISY MEASUREMENTS (NOISE LEVEL IS VARYING) + denoising architecture</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="DenoiCompNet"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet">[docs]</a><span class="k">class</span> <span class="nc">DenoiCompNet</span><span class="p">(</span><span class="n">noiCompNet</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">N0</span><span class="o">=</span><span class="mi">2500</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ord</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Cov</span><span class="p">,</span> <span class="n">variant</span><span class="p">,</span> <span class="n">N0</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">Ord</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Denoised Measurements&quot;</span><span class="p">)</span>
   
<div class="viewcode-block" id="DenoiCompNet.forward"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_acquire</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_reconstruct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="DenoiCompNet.forward_denoise"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_denoise">[docs]</a>    <span class="k">def</span> <span class="nf">forward_denoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="o">+</span><span class="n">var</span><span class="p">),</span> <span class="n">x</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span></div>
   
<div class="viewcode-block" id="DenoiCompNet.forward_reconstruct"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_reconstruct">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">even_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span><span class="p">]</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_denoise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="DenoiCompNet.forward_reconstruct_comp"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_reconstruct_comp">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="DenoiCompNet.forward_reconstruct_mmse"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_reconstruct_mmse">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_mmse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">even_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span><span class="p">]</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_denoise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="DenoiCompNet.forward_reconstruct_pinv"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_reconstruct_pinv">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="DenoiCompNet.forward_reconstruct_mmse_expe"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_reconstruct_mmse_expe">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_mmse_expe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># If C, s, g are arrays, they must have the same dimensions as  x</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">K</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">even_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">uneven_index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sig</span><span class="o">**</span><span class="mi">2</span>       
        <span class="n">x</span><span class="p">,</span> <span class="n">N0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_preprocess_expe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">/</span><span class="n">N0</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># N.B.: N0 = K*alpha</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_denoise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_maptoimage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
    
<div class="viewcode-block" id="DenoiCompNet.forward_reconstruct_expe"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.DenoiCompNet.forward_reconstruct_expe">[docs]</a>    <span class="k">def</span> <span class="nf">forward_reconstruct_expe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>    
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_reconstruct_mmse_expe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>
    
   

<span class="c1">########################################################################</span>
<span class="c1"># 2. Define a custom Loss function</span>
<span class="c1"># ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="c1"># Creating custom loss function</span>
<span class="c1"># ---------------------------</span>
<span class="c1"># Just to make sure that all functions work the same way...   </span>
<span class="c1"># i.e., that they take the same number of arguments</span>

<div class="viewcode-block" id="Weight_Decay_Loss"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Weight_Decay_Loss">[docs]</a><span class="k">class</span> <span class="nc">Weight_Decay_Loss</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Weight_Decay_Loss</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span><span class="p">;</span>

<div class="viewcode-block" id="Weight_Decay_Loss.forward"><a class="viewcode-back" href="../../../api/spyrit.learning.html#spyrit.learning.model_Had_DCAN.Weight_Decay_Loss.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">net</span><span class="p">):</span>
        <span class="n">mse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">mse</span></div></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Antonio Tomas Lorente Mur - Nicolas Ducros - Sebastien Crombez - Thomas Baudier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>